<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paul Graham Essays</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <div class="header-content">
            <img src="paulgraham-ascii.png" alt="Paul Graham ASCII Art" class="header-image">
            <div class="header-text-content">
                <h1>Paul Graham Essays</h1>
                <div class="search-container">
                    <input type="text" class="search-bar" placeholder="Search essays...">
                    <span class="search-clear" onclick="clearSearch()">×</span>
                </div>
            </div>
        </div>
    </header>

    <div class="main-content">
        <div class="filters-sidebar">
            <div class="section-divider">
                <h3 class="section-title">Filter</h3>
                <span class="reset-filters-btn" onclick="resetFilters()">Reset Filter ×</span>
            </div>

            <div class="filter-group filter-section">
                <label class="filter-label collapsed" onclick="toggleFilterSection(this)">Topics</label>
                <div class="filter-content collapsed">
                    <div id="topicTree" class="topic-tree"></div>
                </div>
            </div>

            <div class="filter-group filter-section">
                <label class="filter-label collapsed" onclick="toggleFilterSection(this)">Essay Type</label>
                <div class="filter-content collapsed">
                    <div id="essayTypeTree" class="topic-tree"></div>
                </div>
            </div>

            <div class="filter-group filter-section">
                <label class="filter-label collapsed" onclick="toggleFilterSection(this)">Audience</label>
                <div class="filter-content collapsed">
                    <div id="audienceTree" class="topic-tree"></div>
                </div>
            </div>

            <div class="filter-group filter-section">
                <label class="filter-label collapsed" onclick="toggleFilterSection(this)">Year</label>
                <div class="filter-content collapsed">
                    <div class="range-slider-container">
                        <div class="range-values">
                            <span>Min: <span class="range-value" id="yearMinValue">1996</span></span>
                            <span>Max: <span class="range-value" id="yearMaxValue">2025</span></span>
                        </div>
                        <div class="dual-range-wrapper">
                            <div class="range-track-bg"></div>
                            <div class="range-track-fill" id="yearRangeTrack"></div>
                            <input type="range" id="yearMinSlider" class="range-input range-min" min="1996" max="2025" value="1996" step="1">
                            <input type="range" id="yearMaxSlider" class="range-input range-max" min="1996" max="2025" value="2025" step="1">
                        </div>
                    </div>
                </div>
            </div>

            <div class="filter-group filter-section">
                <label class="filter-label collapsed" onclick="toggleFilterSection(this)">Reading Time (min)</label>
                <div class="filter-content collapsed">
                    <div class="range-slider-container">
                        <div class="range-values">
                            <span>Min: <span class="range-value" id="timeMinValue">0</span></span>
                            <span>Max: <span class="range-value" id="timeMaxValue">70</span></span>
                        </div>
                        <div class="dual-range-wrapper">
                            <div class="range-track-bg"></div>
                            <div class="range-track-fill" id="timeRangeTrack"></div>
                            <input type="range" id="timeMinSlider" class="range-input range-min" min="0" max="70" value="0" step="5">
                            <input type="range" id="timeMaxSlider" class="range-input range-max" min="0" max="70" value="70" step="5">
                        </div>
                    </div>
                </div>
            </div>

            <div class="section-divider">
                <h3 class="section-title">Sort</h3>
                <span class="reset-filters-btn" onclick="resetSort()">Reset Sort ×</span>
            </div>

            <div class="filter-group sort-section">
                <label class="filter-label collapsed" onclick="toggleFilterSection(this)">Date</label>
                <div class="filter-content collapsed">
                    <div class="topic-tree" id="dateSortTree">
                        <div class="tree-item" onclick="setSortOption('date-desc')">
                            <span class="tree-item-label">Newest to Oldest</span>
                        </div>
                        <div class="tree-item" onclick="setSortOption('date-asc')">
                            <span class="tree-item-label">Oldest to Newest</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="filter-group sort-section">
                <label class="filter-label collapsed" onclick="toggleFilterSection(this)">Length</label>
                <div class="filter-content collapsed">
                    <div class="topic-tree" id="lengthSortTree">
                        <div class="tree-item" onclick="setSortOption('length-desc')">
                            <span class="tree-item-label">Longest to Shortest</span>
                        </div>
                        <div class="tree-item" onclick="setSortOption('length-asc')">
                            <span class="tree-item-label">Shortest to Longest</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="middle-pane">
            <div class="essay-count" id="essayCount"></div>
            <div id="essayList"></div>
        </div>

        <div class="right-pane" id="rightPane">
            <div class="preview-header" id="previewHeader"></div>
            <div class="preview-container" id="previewContainer"></div>
        </div>
    </div>

    <script>
        // ========== BOOKMARK FUNCTIONS ==========

        function getBookmarks() {
            return JSON.parse(localStorage.getItem('pg-bookmarks') || '[]');
        }

        function isBookmarked(title) {
            return getBookmarks().includes(title);
        }

        function toggleBookmark(title) {
            let bookmarks = getBookmarks();

            if (bookmarks.includes(title)) {
                bookmarks = bookmarks.filter(b => b !== title);
            } else {
                bookmarks.push(title);
            }

            localStorage.setItem('pg-bookmarks', JSON.stringify(bookmarks));

            // Update the star icon without reloading
            updateBookmarkButton(title);

            // Refresh the list if we're in bookmarked view
            if (currentView === 'bookmarked') {
                applySortAndFilter();
            }
        }

        function updateBookmarkButton(title) {
            const buttons = document.querySelectorAll(`[data-title="${title}"]`);
            buttons.forEach(btn => {
                if (isBookmarked(title)) {
                    btn.classList.add('bookmarked');
                    btn.innerHTML = '★';
                } else {
                    btn.classList.remove('bookmarked');
                    btn.innerHTML = '☆';
                }
            });
        }

        // ========== PREVIEW FUNCTIONS ==========

        let currentlySelectedEssay = null;

        function togglePreview(essay, titleElement) {
            const rightPane = document.getElementById('rightPane');
            const previewHeader = document.getElementById('previewHeader');
            const previewContainer = document.getElementById('previewContainer');

            // If clicking the same essay, close the preview
            if (currentlySelectedEssay && currentlySelectedEssay.Title === essay.Title) {
                rightPane.classList.remove('visible');
                currentlySelectedEssay = null;
                previewHeader.innerHTML = '';
                // Remove selected class from all essay items
                document.querySelectorAll('.essay-item').forEach(item => item.classList.remove('selected'));
            } else {
                // Remove selected class from all essay items
                document.querySelectorAll('.essay-item').forEach(item => item.classList.remove('selected'));
                // Add selected class to clicked item
                if (titleElement) {
                    const essayItem = titleElement.closest('.essay-item');
                    if (essayItem) {
                        essayItem.classList.add('selected');
                    }
                }

                // Add "Go to Original Essay" button in header
                previewHeader.innerHTML = `
                    <a href="${essay.URL}" target="_blank" class="go-to-original-btn">
                        Go to Original Essay
                    </a>
                `;

                // Open preview with new essay
                // Only apply left offset for paulgraham.com URLs
                const isPaulGrahamSite = essay.URL.includes('paulgraham.com');
                const iframeClass = isPaulGrahamSite ? 'preview-iframe' : 'preview-iframe-no-offset';
                previewContainer.innerHTML = `<iframe class="${iframeClass}" src="${essay.URL}"></iframe>`;

                // Listen for iframe navigation to block it and show a message
                const iframe = previewContainer.querySelector('iframe');
                let isInitialLoad = true;

                iframe.addEventListener('load', function() {
                    // Skip the initial load
                    if (isInitialLoad) {
                        isInitialLoad = false;
                        return;
                    }

                    // User clicked a link - replace iframe with message
                    previewContainer.innerHTML = `
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f9fafb; color: #6b7280; font-size: 1.1rem; padding: 2rem; text-align: center;">
                            To navigate to other links, please open the original essay in a new tab.
                        </div>
                    `;
                });

                rightPane.classList.add('visible');
                currentlySelectedEssay = essay;
            }
        }

        function closePreview() {
            const rightPane = document.getElementById('rightPane');
            const previewHeader = document.getElementById('previewHeader');
            rightPane.classList.remove('visible');
            currentlySelectedEssay = null;
            previewHeader.innerHTML = '';
            // Remove selected class from all essay items
            document.querySelectorAll('.essay-item').forEach(item => item.classList.remove('selected'));
        }

        // ========== FILTER SECTION COLLAPSE ==========

        function toggleFilterSection(labelElement) {
            const content = labelElement.nextElementSibling;
            labelElement.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        }

        // ========== LIST RENDERING ==========

        let allEssays = [];
        let currentView = 'all'; // 'all' or 'bookmarked'
        let currentSort = 'date-desc';
        let primarySort = 'date-desc'; // Primary sort criterion
        let secondarySort = null; // Secondary sort criterion
        let userHasSelectedSort = false; // Track if user explicitly selected a sort option
        let selectedTopicPaths = []; // Tracks multiple selected topic paths [[topic, category, item], ...]
        let selectedEssayTypes = []; // Tracks multiple selected essay types
        let selectedAudiences = []; // Tracks multiple selected audiences
        let yearMin = 1996;
        let yearMax = 2025;
        let timeMin = 0;
        let timeMax = 60;
        let searchQuery = '';
        let idfScores = {}; // Pre-computed IDF scores for all terms
        let essayContent = null; // Essay content loaded on page load
        let invertedIndex = {}; // Maps terms to essay IDs containing them (for fast search)
        let searchDebounceTimer = null; // Timer for debounced search

        // ========== TF-IDF FUNCTIONS ==========

        /**
         * Tokenize text: lowercase, split on non-alphanumeric, filter empty
         */
        function tokenize(text) {
            return text
                .toLowerCase()
                .split(/[^a-z0-9]+/)
                .filter(token => token.length > 0);
        }

        /**
         * Compute IDF scores for all terms in the corpus
         * IDF(term) = log(N / df) where N = total docs, df = docs containing term
         * Uses title + content
         */
        function computeIDF(essays) {
            const N = essays.length;
            const termDocFreq = {}; // term -> number of documents containing it

            // Count document frequency for each term
            essays.forEach(essay => {
                let allTokens = new Set(tokenize(essay.Title));

                // Include content if available
                if (essayContent) {
                    const contentEntry = essayContent.find(c => c.ID === essay.ID);
                    if (contentEntry && contentEntry.Content) {
                        const contentTokens = tokenize(contentEntry.Content);
                        contentTokens.forEach(token => allTokens.add(token));
                    }
                }

                // Use Set to count each term once per doc
                allTokens.forEach(token => {
                    termDocFreq[token] = (termDocFreq[token] || 0) + 1;
                });
            });

            // Compute IDF for each term
            const idf = {};
            for (const term in termDocFreq) {
                idf[term] = Math.log(N / termDocFreq[term]);
            }

            return idf;
        }

        /**
         * Build inverted index: maps each term to list of essay IDs containing it
         * This allows us to quickly find which essays contain query terms
         */
        function buildInvertedIndex(essays) {
            const index = {};

            essays.forEach(essay => {
                const titleTokens = new Set(tokenize(essay.Title));

                // Add content tokens if available
                if (essayContent) {
                    const contentEntry = essayContent.find(c => c.ID === essay.ID);
                    if (contentEntry && contentEntry.Content) {
                        const contentTokens = tokenize(contentEntry.Content);
                        contentTokens.forEach(token => titleTokens.add(token));
                    }
                }

                // For each unique token in this essay, add essay ID to index
                titleTokens.forEach(token => {
                    if (!index[token]) {
                        index[token] = [];
                    }
                    index[token].push(essay.ID);
                });
            });

            return index;
        }

        /**
         * Compute TF-IDF score for a query against a document
         * Returns weighted sum of (TF * IDF) for title and content
         * Title matches are weighted 30x more than content matches
         */
        function computeTFIDF(query, essay) {
            const queryTokens = tokenize(query);
            if (queryTokens.length === 0) return 0;

            // Compute TF for title
            const titleTokens = tokenize(essay.Title);
            const titleTF = {};
            titleTokens.forEach(token => {
                titleTF[token] = (titleTF[token] || 0) + 1;
            });

            // Compute TF-IDF score for title (weighted 3x)
            let titleScore = 0;
            queryTokens.forEach(queryTerm => {
                const termFreq = titleTF[queryTerm] || 0;
                const idf = idfScores[queryTerm] || 0;
                titleScore += termFreq * idf;
            });

            // Also search content
            let contentScore = 0;
            if (essayContent) {
                const contentEntry = essayContent.find(c => c.ID === essay.ID);
                if (contentEntry && contentEntry.Content) {
                    const contentTokens = tokenize(contentEntry.Content);
                    const contentTF = {};
                    contentTokens.forEach(token => {
                        contentTF[token] = (contentTF[token] || 0) + 1;
                    });

                    queryTokens.forEach(queryTerm => {
                        const termFreq = contentTF[queryTerm] || 0;
                        const idf = idfScores[queryTerm] || 0;
                        contentScore += termFreq * idf;
                    });
                }
            }

            // Return weighted score: title * 30 + content * 1
            return (titleScore * 30) + contentScore;
        }

        /**
         * Get candidate essays that might match the query using inverted index
         * Only searches essays that contain at least one query term
         */
        function getCandidateEssays(query, allEssays) {
            const queryTokens = tokenize(query);
            if (queryTokens.length === 0) return [];

            // Get all essay IDs that contain at least one query term
            const candidateIDs = new Set();
            queryTokens.forEach(token => {
                const essayIDs = invertedIndex[token] || [];
                essayIDs.forEach(id => candidateIDs.add(id));
            });

            // Return only essays with matching IDs
            return allEssays.filter(essay => candidateIDs.has(essay.ID));
        }


        function toggleView(view) {
            currentView = view;

            // Update button states
            const buttons = document.querySelectorAll('.filter-buttons .filter-btn:not(.sort-btn)');
            buttons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            applySortAndFilter();
        }

        function setSortOption(sortType) {
            const clickedItem = event.target.closest('.tree-item');
            const sortCategory = sortType.startsWith('date') ? 'date' : 'length';

            // Check if clicking on already selected sort to deselect it
            if (sortType === primarySort && userHasSelectedSort) {
                // Deselecting primary (only if it was already explicitly selected)
                if (secondarySort) {
                    primarySort = secondarySort;
                    currentSort = primarySort;
                    secondarySort = null;
                } else {
                    // No secondary, reset to default and mark as not user-selected
                    primarySort = 'date-desc';
                    currentSort = 'date-desc';
                    userHasSelectedSort = false;
                }
            } else if (sortType === secondarySort) {
                // Deselecting secondary
                secondarySort = null;
            } else {
                // Selecting a new sort option
                const wasUserSelected = userHasSelectedSort;
                userHasSelectedSort = true;

                // Determine if this becomes primary or secondary
                const primaryCategory = primarySort.startsWith('date') ? 'date' : 'length';

                if (!wasUserSelected || sortCategory === primaryCategory) {
                    // First explicit selection or clicking within same category - make it primary
                    primarySort = sortType;
                    currentSort = sortType;
                } else {
                    // Clicking different category - make it secondary
                    secondarySort = sortType;
                }
            }

            // Update the UI
            updateSortBadges();
            applySortAndFilter();
        }

        function updateSortBadges() {
            // Remove all badges and selected states
            document.querySelectorAll('#dateSortTree .tree-item, #lengthSortTree .tree-item').forEach(item => {
                item.classList.remove('selected');
                const existingBadge = item.querySelector('.sort-number');
                if (existingBadge) {
                    existingBadge.remove();
                }
            });

            // Only show badges if user has explicitly selected a sort option
            if (!userHasSelectedSort) {
                return;
            }

            // Add badge to primary sort
            if (primarySort) {
                const primaryItem = findSortItem(primarySort);
                if (primaryItem) {
                    primaryItem.classList.add('selected');
                    const badge = document.createElement('span');
                    badge.className = 'sort-number';
                    badge.textContent = '1';
                    primaryItem.querySelector('.tree-item-label').appendChild(badge);
                }
            }

            // Add badge to secondary sort
            if (secondarySort) {
                const secondaryItem = findSortItem(secondarySort);
                if (secondaryItem) {
                    secondaryItem.classList.add('selected');
                    const badge = document.createElement('span');
                    badge.className = 'sort-number';
                    badge.textContent = '2';
                    secondaryItem.querySelector('.tree-item-label').appendChild(badge);
                }
            }
        }

        function findSortItem(sortType) {
            const allSortItems = document.querySelectorAll('#dateSortTree .tree-item, #lengthSortTree .tree-item');
            for (let item of allSortItems) {
                if (item.getAttribute('onclick')?.includes(sortType)) {
                    return item;
                }
            }
            return null;
        }

        function applySortAndFilter() {
            let essays = [...allEssays];

            // Filter by view (all or bookmarked)
            if (currentView === 'bookmarked') {
                const bookmarks = getBookmarks();
                essays = essays.filter(essay => bookmarks.includes(essay.Title));
            }

            // Filter by topic tree selection - match ANY selected path
            if (selectedTopicPaths.length > 0) {
                essays = essays.filter(essay => {
                    // Check if essay matches ANY of the selected paths
                    return selectedTopicPaths.some(selectedPath => {
                        return essay.Topics.some(t => {
                            const [topic, secondLevel, thirdLevel] = selectedPath;

                            // Check if topic matches
                            if (t.topic !== topic) return false;

                            // If only topic is selected, include all essays with this topic
                            if (!secondLevel) return true;

                            // Check if we have a two-level or three-level path
                            if (!thirdLevel) {
                                // Two-level path: could be [topic, directItem] or [topic, category]
                                if (t.subtopics) {
                                    // Check if secondLevel is a direct item (no category) or a category
                                    return t.subtopics.some(subObj => {
                                        // Check if it's a direct item
                                        if (!subObj.category && subObj.items && subObj.items.includes(secondLevel)) {
                                            return true;
                                        }
                                        // Check if it's a category
                                        if (subObj.category === secondLevel) {
                                            return true;
                                        }
                                        return false;
                                    });
                                }
                                return false;
                            } else {
                                // Three-level path: [topic, category, item]
                                if (t.subtopics) {
                                    return t.subtopics.some(subObj => {
                                        return subObj.category === secondLevel &&
                                               subObj.items &&
                                               subObj.items.includes(thirdLevel);
                                    });
                                }
                                return false;
                            }
                        });
                    });
                });
            }

            // Filter by essay type - match ANY selected type
            if (selectedEssayTypes.length > 0) {
                essays = essays.filter(essay =>
                    essay.EssayType && selectedEssayTypes.some(type => essay.EssayType.includes(type))
                );
            }

            // Filter by audience - match ANY selected audience
            if (selectedAudiences.length > 0) {
                essays = essays.filter(essay =>
                    essay.Audience && selectedAudiences.some(aud => essay.Audience.includes(aud))
                );
            }

            // Filter by year range
            essays = essays.filter(essay => essay.Year >= yearMin && essay.Year <= yearMax);

            // Filter by reading time range
            essays = essays.filter(essay => essay.ReadingTime >= timeMin && essay.ReadingTime <= timeMax);

            // Filter by search query and compute TF-IDF scores
            const hasSearchQuery = searchQuery.trim() !== '';
            if (hasSearchQuery) {
                // Use inverted index to get only candidate essays (essays containing query terms)
                const candidates = getCandidateEssays(searchQuery, essays);

                // Compute TF-IDF scores only for candidates
                const scoredEssays = candidates.map(essay => {
                    const score = computeTFIDF(searchQuery, essay);
                    essay._tfidfScore = score;
                    return essay;
                }).filter(essay => essay._tfidfScore > 0);

                essays = scoredEssays;
            }

            // Sort - with primary and secondary criteria
            essays.sort((a, b) => {
                // If there's a search query and no manual sort selected, sort by TF-IDF score
                if (hasSearchQuery && !userHasSelectedSort) {
                    const scoreA = a._tfidfScore || 0;
                    const scoreB = b._tfidfScore || 0;
                    if (scoreB !== scoreA) {
                        return scoreB - scoreA; // Higher scores first
                    }
                    // If TF-IDF scores are equal, fall through to default date sorting
                }

                // Apply primary sort
                let primaryResult = 0;
                switch(primarySort) {
                    case 'date-desc':
                        primaryResult = b.Year - a.Year;
                        // If same year, sort by month
                        if (primaryResult === 0) {
                            primaryResult = (b.Month || 0) - (a.Month || 0);
                        }
                        break;
                    case 'date-asc':
                        primaryResult = a.Year - b.Year;
                        // If same year, sort by month
                        if (primaryResult === 0) {
                            primaryResult = (a.Month || 0) - (b.Month || 0);
                        }
                        break;
                    case 'length-desc':
                        primaryResult = b.WordCount - a.WordCount;
                        break;
                    case 'length-asc':
                        primaryResult = a.WordCount - b.WordCount;
                        break;
                }

                // If primary sort values are equal and there's a secondary sort, apply it
                if (primaryResult === 0 && secondarySort) {
                    switch(secondarySort) {
                        case 'date-desc':
                            const yearDiff = b.Year - a.Year;
                            if (yearDiff === 0) {
                                return (b.Month || 0) - (a.Month || 0);
                            }
                            return yearDiff;
                        case 'date-asc':
                            const yearDiffAsc = a.Year - b.Year;
                            if (yearDiffAsc === 0) {
                                return (a.Month || 0) - (b.Month || 0);
                            }
                            return yearDiffAsc;
                        case 'length-desc':
                            return b.WordCount - a.WordCount;
                        case 'length-asc':
                            return a.WordCount - b.WordCount;
                    }
                }

                return primaryResult;
            });

            renderList(essays);
            updateFilterCounts(essays);
        }

        // ========== UPDATE FILTER COUNTS ==========

        function updateFilterCounts(filteredEssays) {
            // For topic counts: exclude topic filters, include everything else
            let essaysForTopicCounts = [...allEssays];

            // Apply essay type filters
            if (selectedEssayTypes.length > 0) {
                essaysForTopicCounts = essaysForTopicCounts.filter(essay =>
                    essay.EssayType && selectedEssayTypes.some(type => essay.EssayType.includes(type))
                );
            }

            // Apply audience filters
            if (selectedAudiences.length > 0) {
                essaysForTopicCounts = essaysForTopicCounts.filter(essay =>
                    essay.Audience && selectedAudiences.some(aud => essay.Audience.includes(aud))
                );
            }

            // Apply view filter
            if (currentView === 'bookmarked') {
                const bookmarks = getBookmarks();
                essaysForTopicCounts = essaysForTopicCounts.filter(essay => bookmarks.includes(essay.Title));
            }

            // Apply year and reading time filters
            essaysForTopicCounts = essaysForTopicCounts.filter(essay =>
                essay.Year >= yearMin && essay.Year <= yearMax &&
                essay.ReadingTime >= timeMin && essay.ReadingTime <= timeMax
            );

            // Apply search filter using inverted index
            if (searchQuery.trim() !== '') {
                const candidates = getCandidateEssays(searchQuery, essaysForTopicCounts);
                essaysForTopicCounts = candidates.filter(essay => {
                    return computeTFIDF(searchQuery, essay) > 0;
                });
            }

            // Count essays for each topic/category/item
            // Use a Set to ensure each essay is only counted once per filter key
            const topicCounts = {};
            essaysForTopicCounts.forEach(essay => {
                const countedKeys = new Set(); // Track what we've counted for this essay

                essay.Topics.forEach(t => {
                    const topicName = t.topic;

                    // Only count each essay once per topic
                    if (!countedKeys.has(topicName)) {
                        topicCounts[topicName] = (topicCounts[topicName] || 0) + 1;
                        countedKeys.add(topicName);
                    }

                    if (t.subtopics) {
                        t.subtopics.forEach(subObj => {
                            if (subObj.category && subObj.items) {
                                const categoryKey = `${topicName}|${subObj.category}`;

                                // Only count each essay once per category
                                if (!countedKeys.has(categoryKey)) {
                                    topicCounts[categoryKey] = (topicCounts[categoryKey] || 0) + 1;
                                    countedKeys.add(categoryKey);
                                }

                                subObj.items.forEach(item => {
                                    const itemKey = `${topicName}|${subObj.category}|${item}`;

                                    // Only count each essay once per item
                                    if (!countedKeys.has(itemKey)) {
                                        topicCounts[itemKey] = (topicCounts[itemKey] || 0) + 1;
                                        countedKeys.add(itemKey);
                                    }
                                });
                            } else if (subObj.items) {
                                subObj.items.forEach(item => {
                                    const itemKey = `${topicName}|${item}`;

                                    // Only count each essay once per item
                                    if (!countedKeys.has(itemKey)) {
                                        topicCounts[itemKey] = (topicCounts[itemKey] || 0) + 1;
                                        countedKeys.add(itemKey);
                                    }
                                });
                            }
                        });
                    }
                });
            });

            // Update topic tree badges
            document.querySelectorAll('#topicTree .tree-item[data-filter-key]').forEach(item => {
                const filterKey = item.getAttribute('data-filter-key');
                const badge = item.querySelector('.count-badge');
                if (filterKey && badge) {
                    badge.textContent = topicCounts[filterKey] || 0;
                }
            });

            // For essay type counts: exclude essay type filters, include everything else
            let essaysForTypeCounts = [...allEssays];

            // Apply topic filters
            if (selectedTopicPaths.length > 0) {
                essaysForTypeCounts = essaysForTypeCounts.filter(essay => {
                    return selectedTopicPaths.some(selectedPath => {
                        return essay.Topics.some(t => {
                            const [topic, secondLevel, thirdLevel] = selectedPath;
                            if (t.topic !== topic) return false;
                            if (!secondLevel) return true;
                            if (!thirdLevel) {
                                if (t.subtopics) {
                                    return t.subtopics.some(subObj => {
                                        if (!subObj.category && subObj.items && subObj.items.includes(secondLevel)) {
                                            return true;
                                        }
                                        if (subObj.category === secondLevel) {
                                            return true;
                                        }
                                        return false;
                                    });
                                }
                                return false;
                            } else {
                                if (t.subtopics) {
                                    return t.subtopics.some(subObj => {
                                        return subObj.category === secondLevel &&
                                               subObj.items &&
                                               subObj.items.includes(thirdLevel);
                                    });
                                }
                                return false;
                            }
                        });
                    });
                });
            }

            // Apply audience filters
            if (selectedAudiences.length > 0) {
                essaysForTypeCounts = essaysForTypeCounts.filter(essay =>
                    essay.Audience && selectedAudiences.some(aud => essay.Audience.includes(aud))
                );
            }

            if (currentView === 'bookmarked') {
                const bookmarks = getBookmarks();
                essaysForTypeCounts = essaysForTypeCounts.filter(essay => bookmarks.includes(essay.Title));
            }

            // Apply year and reading time filters
            essaysForTypeCounts = essaysForTypeCounts.filter(essay =>
                essay.Year >= yearMin && essay.Year <= yearMax &&
                essay.ReadingTime >= timeMin && essay.ReadingTime <= timeMax
            );

            // Apply search filter using inverted index
            if (searchQuery.trim() !== '') {
                const candidates = getCandidateEssays(searchQuery, essaysForTypeCounts);
                essaysForTypeCounts = candidates.filter(essay => {
                    return computeTFIDF(searchQuery, essay) > 0;
                });
            }

            // Count essays for each essay type
            // Use a Set to ensure each essay is only counted once per type
            const typeCounts = {};
            essaysForTypeCounts.forEach(essay => {
                if (essay.EssayType) {
                    const countedTypes = new Set();
                    essay.EssayType.forEach(type => {
                        const typeKey = `type:${type}`;
                        if (!countedTypes.has(typeKey)) {
                            typeCounts[typeKey] = (typeCounts[typeKey] || 0) + 1;
                            countedTypes.add(typeKey);
                        }
                    });
                }
            });

            // Update essay type badges
            document.querySelectorAll('#essayTypeTree .tree-item[data-filter-key]').forEach(item => {
                const filterKey = item.getAttribute('data-filter-key');
                const badge = item.querySelector('.count-badge');
                if (filterKey && badge) {
                    badge.textContent = typeCounts[filterKey] || 0;
                }
            });

            // For audience counts: exclude audience filters, include everything else
            let essaysForAudienceCounts = [...allEssays];

            // Apply topic filters
            if (selectedTopicPaths.length > 0) {
                essaysForAudienceCounts = essaysForAudienceCounts.filter(essay => {
                    return selectedTopicPaths.some(selectedPath => {
                        return essay.Topics.some(t => {
                            const [topic, secondLevel, thirdLevel] = selectedPath;
                            if (t.topic !== topic) return false;
                            if (!secondLevel) return true;
                            if (!thirdLevel) {
                                if (t.subtopics) {
                                    return t.subtopics.some(subObj => {
                                        if (!subObj.category && subObj.items && subObj.items.includes(secondLevel)) {
                                            return true;
                                        }
                                        if (subObj.category === secondLevel) {
                                            return true;
                                        }
                                        return false;
                                    });
                                }
                                return false;
                            } else {
                                if (t.subtopics) {
                                    return t.subtopics.some(subObj => {
                                        return subObj.category === secondLevel &&
                                               subObj.items &&
                                               subObj.items.includes(thirdLevel);
                                    });
                                }
                                return false;
                            }
                        });
                    });
                });
            }

            // Apply essay type filters
            if (selectedEssayTypes.length > 0) {
                essaysForAudienceCounts = essaysForAudienceCounts.filter(essay =>
                    essay.EssayType && selectedEssayTypes.some(type => essay.EssayType.includes(type))
                );
            }

            if (currentView === 'bookmarked') {
                const bookmarks = getBookmarks();
                essaysForAudienceCounts = essaysForAudienceCounts.filter(essay => bookmarks.includes(essay.Title));
            }

            // Apply year and reading time filters
            essaysForAudienceCounts = essaysForAudienceCounts.filter(essay =>
                essay.Year >= yearMin && essay.Year <= yearMax &&
                essay.ReadingTime >= timeMin && essay.ReadingTime <= timeMax
            );

            // Apply search filter using inverted index
            if (searchQuery.trim() !== '') {
                const candidates = getCandidateEssays(searchQuery, essaysForAudienceCounts);
                essaysForAudienceCounts = candidates.filter(essay => {
                    return computeTFIDF(searchQuery, essay) > 0;
                });
            }

            // Count essays for each audience
            // Use a Set to ensure each essay is only counted once per audience
            const audienceCounts = {};
            essaysForAudienceCounts.forEach(essay => {
                if (essay.Audience) {
                    const countedAudiences = new Set();
                    essay.Audience.forEach(aud => {
                        const audKey = `audience:${aud}`;
                        if (!countedAudiences.has(audKey)) {
                            audienceCounts[audKey] = (audienceCounts[audKey] || 0) + 1;
                            countedAudiences.add(audKey);
                        }
                    });
                }
            });

            // Update audience badges
            document.querySelectorAll('#audienceTree .tree-item[data-filter-key]').forEach(item => {
                const filterKey = item.getAttribute('data-filter-key');
                const badge = item.querySelector('.count-badge');
                if (filterKey && badge) {
                    badge.textContent = audienceCounts[filterKey] || 0;
                }
            });
        }

        // ========== TOPIC TREE FUNCTIONS ==========

        function createTreeItem(label, count, level, onClick, dataKey = null) {
            const item = document.createElement('div');
            item.className = 'tree-item';
            if (level > 1) {
                item.classList.add(`tree-level-${level}`);
            }

            // Add data attribute for easier lookup
            if (dataKey) {
                item.setAttribute('data-filter-key', dataKey);
            }

            const labelSpan = document.createElement('span');
            labelSpan.className = 'tree-item-label';
            labelSpan.textContent = label;

            const badge = document.createElement('span');
            badge.className = 'count-badge';
            badge.textContent = count;

            item.appendChild(labelSpan);
            item.appendChild(badge);
            item.onclick = (e) => {
                e.stopPropagation();
                onClick();
            };

            return item;
        }

        // ========== PATH HELPER FUNCTIONS ==========

        function pathsEqual(path1, path2) {
            return path1.length === path2.length &&
                   path1.every((item, i) => item === path2[i]);
        }

        function isAncestor(ancestorPath, childPath) {
            // An ancestor is shorter and matches the beginning of the child
            return childPath.length > ancestorPath.length &&
                   ancestorPath.every((item, i) => item === childPath[i]);
        }

        function isDescendant(descendantPath, parentPath) {
            // A descendant is longer and the parent matches its beginning
            return descendantPath.length > parentPath.length &&
                   parentPath.every((item, i) => item === descendantPath[i]);
        }

        // ========== TOPIC SELECTION HANDLERS ==========

        function handleTopicClick(topicName) {
            // Toggle expansion
            const childrenContainer = document.getElementById(`children-${topicName}`);
            childrenContainer.classList.toggle('expanded');

            // Toggle selection
            const path = [topicName];
            toggleTopicSelection(path);
        }

        function handleCategoryClick(topicName, categoryName) {
            // Toggle expansion
            const childrenContainer = document.getElementById(`children-${topicName}-${categoryName}`);
            childrenContainer.classList.toggle('expanded');

            // Toggle selection
            const path = [topicName, categoryName];
            toggleTopicSelection(path);
        }

        function handleDirectItemClick(topicName, itemName) {
            // For two-level structure (no category) - toggle selection
            const path = [topicName, itemName];
            toggleTopicSelection(path);
        }

        function handleItemClick(topicName, categoryName, itemName) {
            // For three-level structure (with category) - toggle selection
            const path = [topicName, categoryName, itemName];
            toggleTopicSelection(path);
        }

        function toggleTopicSelection(path) {
            const isSelected = selectedTopicPaths.some(p => pathsEqual(p, path));
            const hasDescendants = selectedTopicPaths.some(p => isDescendant(p, path));

            if (isSelected || hasDescendants) {
                // DESELECTING: Remove this path and all its descendants
                selectedTopicPaths = selectedTopicPaths.filter(p =>
                    !pathsEqual(p, path) && !isDescendant(p, path)
                );

                // Collapse all children containers under this path
                collapseChildrenContainers(path);

                // If this path has a parent and no other children remain under that parent,
                // re-select the parent
                if (path.length > 1) {
                    const parentPath = path.slice(0, -1);
                    const hasOtherChildren = selectedTopicPaths.some(p => isDescendant(p, parentPath));

                    if (!hasOtherChildren) {
                        selectedTopicPaths.push(parentPath);
                    }
                }
            } else {
                // SELECTING: Remove any ancestors or descendants first, then add this path
                selectedTopicPaths = selectedTopicPaths.filter(p =>
                    !isAncestor(p, path) && !isDescendant(p, path)
                );
                selectedTopicPaths.push(path);
            }

            updateTreeSelection();
            applySortAndFilter();
        }

        function collapseChildrenContainers(path) {
            // Collapse the children container for this path and all descendants
            if (path.length === 1) {
                // Topic level: collapse children-{topicName}
                const container = document.getElementById(`children-${path[0]}`);
                if (container) {
                    container.classList.remove('expanded');
                }
                // Also collapse all nested children under this topic
                const allContainers = document.querySelectorAll(`[id^="children-${path[0]}-"]`);
                allContainers.forEach(c => c.classList.remove('expanded'));
            } else if (path.length === 2) {
                // Category level: collapse children-{topicName}-{categoryName}
                const container = document.getElementById(`children-${path[0]}-${path[1]}`);
                if (container) {
                    container.classList.remove('expanded');
                }
            }
            // For item level (length === 3), there are no children to collapse
        }

        function updateTreeSelection() {
            // Remove all selected states from filter items only (not sort items)
            document.querySelectorAll('#topicTree .tree-item, #essayTypeTree .tree-item, #audienceTree .tree-item').forEach(el => {
                el.classList.remove('selected');
            });

            // Add selected state to topic items
            if (selectedTopicPaths.length > 0) {
                const topicItems = document.querySelectorAll('#topicTree .tree-item');
                topicItems.forEach(item => {
                    const label = item.querySelector('.tree-item-label').textContent;
                    // Check if this label is in any of the selected paths
                    const isSelected = selectedTopicPaths.some(path => path.includes(label));
                    if (isSelected) {
                        item.classList.add('selected');
                    }
                });
            }

            // Update essay type selection
            if (selectedEssayTypes.length > 0) {
                const essayTypeItems = document.querySelectorAll('#essayTypeTree .tree-item');
                essayTypeItems.forEach(item => {
                    const label = item.querySelector('.tree-item-label').textContent;
                    if (selectedEssayTypes.includes(label)) {
                        item.classList.add('selected');
                    }
                });
            }

            // Update audience selection
            if (selectedAudiences.length > 0) {
                const audienceItems = document.querySelectorAll('#audienceTree .tree-item');
                audienceItems.forEach(item => {
                    const label = item.querySelector('.tree-item-label').textContent;
                    if (selectedAudiences.includes(label)) {
                        item.classList.add('selected');
                    }
                });
            }
        }

        function handleEssayTypeClick(essayType) {
            // Toggle selection
            const index = selectedEssayTypes.indexOf(essayType);
            if (index >= 0) {
                selectedEssayTypes.splice(index, 1);
            } else {
                selectedEssayTypes.push(essayType);
            }
            updateTreeSelection();
            applySortAndFilter();
        }

        function handleAudienceClick(audience) {
            // Toggle selection
            const index = selectedAudiences.indexOf(audience);
            if (index >= 0) {
                selectedAudiences.splice(index, 1);
            } else {
                selectedAudiences.push(audience);
            }
            updateTreeSelection();
            applySortAndFilter();
        }

        // ========== RESET FILTERS ==========

        function resetFilters() {
            // Clear all selections
            selectedTopicPaths = [];
            selectedEssayTypes = [];
            selectedAudiences = [];

            // Reset range sliders to full range
            const yearMinSlider = document.getElementById('yearMinSlider');
            const yearMaxSlider = document.getElementById('yearMaxSlider');
            const timeMinSlider = document.getElementById('timeMinSlider');
            const timeMaxSlider = document.getElementById('timeMaxSlider');

            if (yearMinSlider) {
                const minYear = parseInt(yearMinSlider.min);
                const maxYear = parseInt(yearMaxSlider.max);
                yearMin = minYear;
                yearMax = maxYear;
                yearMinSlider.value = yearMin;
                yearMaxSlider.value = yearMax;
                document.getElementById('yearMinValue').textContent = yearMin;
                document.getElementById('yearMaxValue').textContent = yearMax;
                updateRangeFill('year', minYear, maxYear);
            }

            if (timeMinSlider) {
                const minTime = parseInt(timeMinSlider.min);
                const maxTime = parseInt(timeMaxSlider.max);
                timeMin = minTime;
                timeMax = maxTime;
                timeMinSlider.value = timeMin;
                timeMaxSlider.value = timeMax;
                document.getElementById('timeMinValue').textContent = timeMin;
                document.getElementById('timeMaxValue').textContent = timeMax;
                updateRangeFill('time', minTime, maxTime);
            }

            // Collapse only filter sections (not sort sections)
            document.querySelectorAll('.filter-section .filter-label').forEach(label => {
                label.classList.add('collapsed');
                label.nextElementSibling.classList.add('collapsed');
            });

            // Collapse all expanded categories in the topic tree
            document.querySelectorAll('[id^="children-"]').forEach(container => {
                container.classList.remove('expanded');
            });

            // Update UI and apply filters
            updateTreeSelection();
            applySortAndFilter();
        }

        function resetSort() {
            // Reset to default sort (newest first)
            primarySort = 'date-desc';
            secondarySort = null;
            currentSort = 'date-desc';
            userHasSelectedSort = false; // Mark as not user-selected

            // Collapse only sort sections (not filter sections)
            document.querySelectorAll('.sort-section .filter-label').forEach(label => {
                label.classList.add('collapsed');
                label.nextElementSibling.classList.add('collapsed');
            });

            // Update UI and apply sort
            updateSortBadges();
            applySortAndFilter();
        }

        function clearSearch() {
            // Clear the search input
            const searchBar = document.querySelector('.search-bar');
            const searchClear = document.querySelector('.search-clear');

            searchBar.value = '';
            searchQuery = '';
            searchClear.classList.remove('visible');

            // Reset sort selection when clearing search
            if (userHasSelectedSort) {
                userHasSelectedSort = false;
                primarySort = 'date-desc';
                secondarySort = null;
                currentSort = 'date-desc';
                updateSortBadges();
            }

            // Re-apply filters without search
            applySortAndFilter();
        }

        // ========== RANGE SLIDER FUNCTIONS ==========

        function initRangeSliders() {
            // Calculate min and max from the data
            const years = allEssays.map(e => e.Year);
            const times = allEssays.map(e => e.ReadingTime);

            const minYear = Math.min(...years);
            const maxYear = Math.max(...years);
            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);

            // Update slider attributes
            document.getElementById('yearMinSlider').min = minYear;
            document.getElementById('yearMinSlider').max = maxYear;
            document.getElementById('yearMinSlider').value = minYear;
            document.getElementById('yearMaxSlider').min = minYear;
            document.getElementById('yearMaxSlider').max = maxYear;
            document.getElementById('yearMaxSlider').value = maxYear;

            document.getElementById('timeMinSlider').min = minTime;
            document.getElementById('timeMinSlider').max = maxTime;
            document.getElementById('timeMinSlider').value = minTime;
            document.getElementById('timeMaxSlider').min = minTime;
            document.getElementById('timeMaxSlider').max = maxTime;
            document.getElementById('timeMaxSlider').value = maxTime;

            // Update global variables
            yearMin = minYear;
            yearMax = maxYear;
            timeMin = minTime;
            timeMax = maxTime;

            // Update displayed values
            document.getElementById('yearMinValue').textContent = minYear;
            document.getElementById('yearMaxValue').textContent = maxYear;
            document.getElementById('timeMinValue').textContent = minTime;
            document.getElementById('timeMaxValue').textContent = maxTime;

            // Add event listeners
            const yearMinSlider = document.getElementById('yearMinSlider');
            const yearMaxSlider = document.getElementById('yearMaxSlider');
            const timeMinSlider = document.getElementById('timeMinSlider');
            const timeMaxSlider = document.getElementById('timeMaxSlider');

            yearMinSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value <= yearMax) {
                    yearMin = value;
                    document.getElementById('yearMinValue').textContent = value;
                    updateRangeFill('year', minYear, maxYear);
                    applySortAndFilter();
                } else {
                    e.target.value = yearMax;
                }
            });

            yearMaxSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value >= yearMin) {
                    yearMax = value;
                    document.getElementById('yearMaxValue').textContent = value;
                    updateRangeFill('year', minYear, maxYear);
                    applySortAndFilter();
                } else {
                    e.target.value = yearMin;
                }
            });

            timeMinSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value <= timeMax) {
                    timeMin = value;
                    document.getElementById('timeMinValue').textContent = value;
                    updateRangeFill('time', minTime, maxTime);
                    applySortAndFilter();
                } else {
                    e.target.value = timeMax;
                }
            });

            timeMaxSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                if (value >= timeMin) {
                    timeMax = value;
                    document.getElementById('timeMaxValue').textContent = value;
                    updateRangeFill('time', minTime, maxTime);
                    applySortAndFilter();
                } else {
                    e.target.value = timeMin;
                }
            });

            // Initial fill update
            updateRangeFill('year', minYear, maxYear);
            updateRangeFill('time', minTime, maxTime);
        }

        function updateRangeFill(type, min, max) {
            const trackFill = document.getElementById(type === 'year' ? 'yearRangeTrack' : 'timeRangeTrack');
            const currentMin = type === 'year' ? yearMin : timeMin;
            const currentMax = type === 'year' ? yearMax : timeMax;

            const range = max - min;
            const leftPercent = ((currentMin - min) / range) * 100;
            const rightPercent = ((currentMax - min) / range) * 100;

            trackFill.style.left = leftPercent + '%';
            trackFill.style.width = (rightPercent - leftPercent) + '%';
        }

        function populateFilters() {
            // Build topic hierarchy with counts
            const topicHierarchy = {};

            allEssays.forEach(essay => {
                essay.Topics.forEach(t => {
                    const topicName = t.topic;

                    if (!topicHierarchy[topicName]) {
                        topicHierarchy[topicName] = { count: 0, categories: {}, directItems: {} };
                    }
                    topicHierarchy[topicName].count++;

                    if (t.subtopics) {
                        t.subtopics.forEach(subObj => {
                            if (subObj.category && subObj.items) {
                                // Has category - three level structure
                                const categoryName = subObj.category;

                                if (!topicHierarchy[topicName].categories[categoryName]) {
                                    topicHierarchy[topicName].categories[categoryName] = { count: 0, items: {} };
                                }
                                topicHierarchy[topicName].categories[categoryName].count++;

                                subObj.items.forEach(item => {
                                    if (!topicHierarchy[topicName].categories[categoryName].items[item]) {
                                        topicHierarchy[topicName].categories[categoryName].items[item] = 0;
                                    }
                                    topicHierarchy[topicName].categories[categoryName].items[item]++;
                                });
                            } else if (subObj.items) {
                                // No category - two level structure (direct items under topic)
                                subObj.items.forEach(item => {
                                    if (!topicHierarchy[topicName].directItems[item]) {
                                        topicHierarchy[topicName].directItems[item] = 0;
                                    }
                                    topicHierarchy[topicName].directItems[item]++;
                                });
                            }
                        });
                    }
                });
            });

            // Build the tree UI
            const topicTree = document.getElementById('topicTree');
            topicTree.innerHTML = '';

            // Sort topics by count (descending)
            Object.keys(topicHierarchy).sort((a, b) => topicHierarchy[b].count - topicHierarchy[a].count).forEach(topicName => {
                const topicData = topicHierarchy[topicName];
                const topicItem = createTreeItem(topicName, topicData.count, 1, () => handleTopicClick(topicName), topicName);
                topicTree.appendChild(topicItem);

                // Create children container
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'tree-children';
                childrenContainer.id = `children-${topicName}`;

                // Add direct items (two-level structure)
                // Custom order for specific topics with direct items
                const directItemKeys = Object.keys(topicData.directItems);
                if (topicName === 'Society') {
                    const societyOrder = ['Social Commentary', 'Philosophy', 'Economics and Policy', 'Education'];
                    directItemKeys.sort((a, b) => {
                        const indexA = societyOrder.indexOf(a);
                        const indexB = societyOrder.indexOf(b);
                        if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                        if (indexA !== -1) return -1;
                        if (indexB !== -1) return 1;
                        return a.localeCompare(b);
                    });
                } else if (topicName === 'Communication') {
                    const communicationOrder = ['Writing', 'Media'];
                    directItemKeys.sort((a, b) => {
                        const indexA = communicationOrder.indexOf(a);
                        const indexB = communicationOrder.indexOf(b);
                        if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                        if (indexA !== -1) return -1;
                        if (indexB !== -1) return 1;
                        return a.localeCompare(b);
                    });
                } else {
                    directItemKeys.sort();
                }

                directItemKeys.forEach(itemName => {
                    const itemCount = topicData.directItems[itemName];
                    const itemElement = createTreeItem(itemName, itemCount, 2, () => handleDirectItemClick(topicName, itemName), `${topicName}|${itemName}`);
                    childrenContainer.appendChild(itemElement);
                });

                // Add categories (three-level structure)
                // Custom order for Startups categories
                const categoryKeys = Object.keys(topicData.categories);
                if (topicName === 'Startups') {
                    const startupsOrder = ['The Startup World', 'Getting Started', 'Running a Startup', 'Funding & Finance'];
                    categoryKeys.sort((a, b) => {
                        const indexA = startupsOrder.indexOf(a);
                        const indexB = startupsOrder.indexOf(b);
                        if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                        if (indexA !== -1) return -1;
                        if (indexB !== -1) return 1;
                        return a.localeCompare(b);
                    });
                } else {
                    categoryKeys.sort();
                }

                categoryKeys.forEach(categoryName => {
                    const categoryData = topicData.categories[categoryName];
                    const categoryItem = createTreeItem(categoryName, categoryData.count, 2, () => handleCategoryClick(topicName, categoryName), `${topicName}|${categoryName}`);
                    childrenContainer.appendChild(categoryItem);

                    // Create children container for items under category
                    const itemsContainer = document.createElement('div');
                    itemsContainer.className = 'tree-children';
                    itemsContainer.id = `children-${topicName}-${categoryName}`;

                    // Custom order for specific Startups categories
                    const itemKeys = Object.keys(categoryData.items);
                    if (topicName === 'Startups' && categoryName === 'The Startup World') {
                        const startupWorldOrder = ['Y Combinator', 'Founder Life', 'Startup Landscape', 'Startup Hubs'];
                        itemKeys.sort((a, b) => {
                            const indexA = startupWorldOrder.indexOf(a);
                            const indexB = startupWorldOrder.indexOf(b);
                            if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                            if (indexA !== -1) return -1;
                            if (indexB !== -1) return 1;
                            return a.localeCompare(b);
                        });
                    } else if (topicName === 'Startups' && categoryName === 'Getting Started') {
                        const gettingStartedOrder = ['Starting a Company', 'Ideas'];
                        itemKeys.sort((a, b) => {
                            const indexA = gettingStartedOrder.indexOf(a);
                            const indexB = gettingStartedOrder.indexOf(b);
                            if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                            if (indexA !== -1) return -1;
                            if (indexB !== -1) return 1;
                            return a.localeCompare(b);
                        });
                    } else if (topicName === 'Startups' && categoryName === 'Running a Startup') {
                        const runningStartupOrder = ['Founder Life', 'Strategy and Growth', 'Failure'];
                        itemKeys.sort((a, b) => {
                            const indexA = runningStartupOrder.indexOf(a);
                            const indexB = runningStartupOrder.indexOf(b);
                            if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                            if (indexA !== -1) return -1;
                            if (indexB !== -1) return 1;
                            return a.localeCompare(b);
                        });
                    } else if (topicName === 'Startups' && categoryName === 'Funding & Finance') {
                        const fundingFinanceOrder = ['Funding and Investing', 'Runway', 'Exits'];
                        itemKeys.sort((a, b) => {
                            const indexA = fundingFinanceOrder.indexOf(a);
                            const indexB = fundingFinanceOrder.indexOf(b);
                            if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                            if (indexA !== -1) return -1;
                            if (indexB !== -1) return 1;
                            return a.localeCompare(b);
                        });
                    } else {
                        itemKeys.sort();
                    }

                    itemKeys.forEach(itemName => {
                        const itemCount = categoryData.items[itemName];
                        const itemElement = createTreeItem(itemName, itemCount, 3, () => handleItemClick(topicName, categoryName, itemName), `${topicName}|${categoryName}|${itemName}`);
                        itemsContainer.appendChild(itemElement);
                    });

                    childrenContainer.appendChild(itemsContainer);
                });

                topicTree.appendChild(childrenContainer);
            });

            // Populate essay types with counts
            const essayTypeCounts = {};
            allEssays.forEach(essay => {
                if (essay.EssayType) {
                    essay.EssayType.forEach(type => {
                        if (!essayTypeCounts[type]) {
                            essayTypeCounts[type] = 0;
                        }
                        essayTypeCounts[type]++;
                    });
                }
            });

            const essayTypeTree = document.getElementById('essayTypeTree');
            essayTypeTree.innerHTML = '';
            // Sort essay types by count (descending)
            Object.keys(essayTypeCounts).sort((a, b) => essayTypeCounts[b] - essayTypeCounts[a]).forEach(type => {
                const count = essayTypeCounts[type];
                const item = createTreeItem(type, count, 1, () => handleEssayTypeClick(type), `type:${type}`);
                essayTypeTree.appendChild(item);
            });

            // Populate audiences with counts
            const audienceCounts = {};
            allEssays.forEach(essay => {
                if (essay.Audience) {
                    essay.Audience.forEach(aud => {
                        if (!audienceCounts[aud]) {
                            audienceCounts[aud] = 0;
                        }
                        audienceCounts[aud]++;
                    });
                }
            });

            const audienceTree = document.getElementById('audienceTree');
            audienceTree.innerHTML = '';
            // Sort audiences by custom order
            const audienceOrder = ['General', 'Founders', 'Hackers and Makers', 'Investors', 'Writers'];
            const sortedAudiences = Object.keys(audienceCounts).sort((a, b) => {
                const indexA = audienceOrder.indexOf(a);
                const indexB = audienceOrder.indexOf(b);
                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                if (indexA !== -1) return -1;
                if (indexB !== -1) return 1;
                return a.localeCompare(b);
            });
            sortedAudiences.forEach(audience => {
                const count = audienceCounts[audience];
                const item = createTreeItem(audience, count, 1, () => handleAudienceClick(audience), `audience:${audience}`);
                audienceTree.appendChild(item);
            });
        }

        function renderList(essays) {
            const container = document.getElementById('essayList');
            const countDiv = document.getElementById('essayCount');

            countDiv.innerHTML = `Showing ${essays.length} essays`;

            if (essays.length === 0) {
                container.innerHTML = '<p style="text-align: center; padding: 2rem; color: #718096;">No essays found. Start bookmarking essays to create your reading list!</p>';
                return;
            }

            container.innerHTML = '';

            essays.forEach(essay => {
                const item = document.createElement('div');
                item.className = 'essay-item';

                // Apply selected class if this is the currently selected essay
                if (currentlySelectedEssay && currentlySelectedEssay.Title === essay.Title) {
                    item.classList.add('selected');
                }

                // Create bookmark button
                const bookmarkBtn = document.createElement('button');
                bookmarkBtn.className = 'bookmark-btn' + (isBookmarked(essay.Title) ? ' bookmarked' : '');
                bookmarkBtn.innerHTML = isBookmarked(essay.Title) ? '★' : '☆';
                bookmarkBtn.setAttribute('data-title', essay.Title);
                bookmarkBtn.onclick = (e) => {
                    e.stopPropagation();
                    toggleBookmark(essay.Title);
                };

                // Create title
                const title = document.createElement('div');
                title.className = 'essay-title';

                const titleText = document.createElement('span');
                titleText.textContent = essay.Title;
                title.appendChild(titleText);

                // Create meta info container (date and reading time)
                const metaInfo = document.createElement('div');
                metaInfo.className = 'essay-meta-info';

                // Create date info (plain text with calendar icon)
                const dateInfo = document.createElement('div');
                dateInfo.className = 'essay-date-info';
                dateInfo.innerHTML = `
                    <svg class="calendar-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                        <line x1="16" y1="2" x2="16" y2="6"></line>
                        <line x1="8" y1="2" x2="8" y2="6"></line>
                        <line x1="3" y1="10" x2="21" y2="10"></line>
                    </svg>
                    <span class="date-text">${essay.Date}</span>
                `;

                // Create reading time info (plain text with clock icon)
                const timeInfo = document.createElement('div');
                timeInfo.className = 'essay-time-info';
                timeInfo.innerHTML = `
                    <svg class="clock-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                    <span class="time-text">${essay.ReadingTime} min</span>
                `;

                // Create audience info (with icon)
                const audienceInfo = document.createElement('div');
                audienceInfo.className = 'essay-audience-info';
                if (essay.Audience && essay.Audience.length > 0) {
                    audienceInfo.innerHTML = `
                        <svg class="audience-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span class="audience-text">${essay.Audience.join(', ')}</span>
                    `;
                }

                // Create essay type info (with icon)
                const typeInfo = document.createElement('div');
                typeInfo.className = 'essay-type-info';
                if (essay.EssayType && essay.EssayType.length > 0) {
                    typeInfo.innerHTML = `
                        <svg class="type-icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="16" y1="13" x2="8" y2="13"></line>
                            <line x1="16" y1="17" x2="8" y2="17"></line>
                            <polyline points="10 9 9 9 8 9"></polyline>
                        </svg>
                        <span class="type-text">${essay.EssayType.join(', ')}</span>
                    `;
                }

                // Add all items to metaInfo
                metaInfo.appendChild(dateInfo);
                metaInfo.appendChild(timeInfo);
                if (essay.Audience && essay.Audience.length > 0) {
                    metaInfo.appendChild(audienceInfo);
                }
                if (essay.EssayType && essay.EssayType.length > 0) {
                    metaInfo.appendChild(typeInfo);
                }

                // Create tags container for topic tags only
                const tagsContainer = document.createElement('div');
                tagsContainer.className = 'essay-tags';

                // Add topic tags (grouped by topic) with color coding
                essay.Topics.forEach(topic => {
                    if (topic.subtopics && topic.subtopics.length > 0) {
                        // Collect all subtopic items for this topic
                        const allItems = [];
                        topic.subtopics.forEach(subObj => {
                            if (subObj.items && subObj.items.length > 0) {
                                allItems.push(...subObj.items);
                            }
                        });

                        // Create a single tag with all items
                        if (allItems.length > 0) {
                            const topicTag = document.createElement('span');
                            topicTag.className = `tag topic-tag topic-${topic.topic.toLowerCase().replace(/\s+/g, '-')}`;
                            topicTag.textContent = `${topic.topic}: ${allItems.join(', ')}`;
                            tagsContainer.appendChild(topicTag);
                        }
                    } else {
                        // No subtopics, just show the topic
                        const topicTag = document.createElement('span');
                        topicTag.className = `tag topic-tag topic-${topic.topic.toLowerCase().replace(/\s+/g, '-')}`;
                        topicTag.textContent = topic.topic;
                        tagsContainer.appendChild(topicTag);
                    }
                });

                // Create content wrapper
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'essay-content';
                contentWrapper.appendChild(title);
                contentWrapper.appendChild(metaInfo);
                contentWrapper.appendChild(tagsContainer);

                // Assemble the item
                item.appendChild(bookmarkBtn);
                item.appendChild(contentWrapper);

                // Add click handler to toggle preview
                item.onclick = (e) => {
                    if (e.target.classList.contains('bookmark-btn')) {
                        return;
                    }
                    // Don't trigger if clicking the external link icon
                    if (e.target.classList.contains('external-link-icon')) {
                        return;
                    }
                    togglePreview(essay, title);
                };

                container.appendChild(item);
            });
        }

        // ========== LOAD DATA ==========

        // Load both essays.json and essay-content.json in parallel
        Promise.all([
            fetch('./essays.json').then(r => r.json()),
            fetch('./essay-content.json').then(r => r.json())
        ])
            .then(([essaysData, contentData]) => {
                allEssays = essaysData.essays;
                essayContent = contentData.content;

                console.log('Building search index...');

                // Pre-compute IDF scores with full content
                idfScores = computeIDF(allEssays);

                // Build inverted index for fast search
                invertedIndex = buildInvertedIndex(allEssays);

                console.log('Search index ready!');

                populateFilters();
                initRangeSliders(); // Initialize year and reading time sliders
                updateSortBadges(); // Show initial sort badge
                applySortAndFilter();

                // Add search functionality with debouncing
                const searchBar = document.querySelector('.search-bar');
                const searchClear = document.querySelector('.search-clear');

                searchBar.addEventListener('input', (e) => {
                    const newQuery = e.target.value;
                    const queryChanged = newQuery !== searchQuery;
                    searchQuery = newQuery;

                    // Show/hide clear button
                    if (searchQuery.trim() !== '') {
                        searchClear.classList.add('visible');

                        // Reset sort selection when search query changes
                        if (queryChanged && userHasSelectedSort) {
                            userHasSelectedSort = false;
                            primarySort = 'date-desc';
                            secondarySort = null;
                            currentSort = 'date-desc';
                            updateSortBadges();
                        }
                    } else {
                        searchClear.classList.remove('visible');
                    }

                    // Debounce: wait 300ms after user stops typing
                    clearTimeout(searchDebounceTimer);
                    searchDebounceTimer = setTimeout(() => {
                        applySortAndFilter();
                    }, 300);
                });
            })
            .catch(error => {
                console.error('Error loading data:', error);
                document.getElementById('essayList').innerHTML =
                    '<p style="text-align: center; padding: 2rem; color: #e53e3e;">Error loading essays. Please refresh the page.</p>';
            });
    </script>
</body>
</html>
